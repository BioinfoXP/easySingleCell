setwd(here::here())
source('./script/config.R')

sce <- qread('./output_data/Figure5/sce.tumor.qs')

path1 <- "/home/xiapeng/R_wls2/cervix_cancer/"
path2 <- "/home/xiapeng/R_wls2/singularity/pyscenic/cervix_cancer/"
dir.create(path2)

DimPlot(sce,label = T,repel = T)
# =================== 1.定义函数 =================== 
# makeMetaCells
makeMetaCells <- function(seu, min.cells = 10, reduction = "umap", dims = 1:2, k.param = 10, cores = 20) {
  seu <- seu %>%
    FindNeighbors(reduction = reduction, dims = dims, k.param = k.param) %>%
    FindClusters(res = 50)
  metadata <- seu@meta.data
  metadata$METACELL_ID <- factor(metadata$seurat_clusters)
  dge_mat <- seu[["RNA"]]@counts
  
  dge_mat_mc <- parallel::mclapply(levels(metadata$METACELL_ID), function(xx) {
    cells <- rownames(subset(metadata, METACELL_ID == xx))
    Matrix::rowSums(dge_mat[, cells])
  }, mc.cores = cores)
  dge_mat_mc <- do.call(cbind, dge_mat_mc)
  
  metacell_metadata <- metadata[["METACELL_ID"]] %>% table() %>% as.data.frame()
  colnames(metacell_metadata) <- c("METACELL_ID", "CELL_COUNT")
  rownames(metacell_metadata) <- metacell_metadata[["METACELL_ID"]]
  
  kept.cells <- subset(metacell_metadata, CELL_COUNT >= min.cells)[["METACELL_ID"]]
  metacells <- list(
    mat = dge_mat_mc[, kept.cells],
    metadata = metacell_metadata[kept.cells, ]
  )
  colnames(metacells$mat) <- paste0(seu@project.name, ".METACELL_", kept.cells)
  rownames(metacells$metadata) <- colnames(metacells$mat)
  return(metacells)
}




# =================== 2.数据加载 =================== 
setwd(path1)

DimPlot(sce,group.by = 'cell_type')
# =================== 3.向下采样 =================== 
# 降低细胞数量
seu <- sce
table(seu$cell_type,seu$orig.ident)


# =================== 4.MetaCell =================== 
# 创建metacell，同时进一步降低细胞数量！
# 
# 注意：按样本处理!
seu.list <- SplitObject(seu, split.by = "cell_type")
names(seu.list)
for (i in 1:length(names(seu.list))) {
  seu.list[[i]]@project.name <- names(seu.list)[i]
}
names(seu.list)


metacells.list <- lapply(seq_along(seu.list), function(ii) {
  makeMetaCells(
    seu       = seu.list[[ii]],
    min.cells = 0, #10
    reduction = "umap",
    dims      = 1:2,
    k.param   = 10,
    cores     = 10)
})


# =================== 5.输出表达矩阵 =================== 

mc.mat <- lapply(metacells.list, function(mc) mc$mat) %>% Reduce(cbind, .)
mc.cellmeta <- lapply(metacells.list, function(mc) mc$metadata) %>% Reduce(rbind, .)
dim(mc.mat)

## 保存结果(meta cell matrix)
setwd(path2)
saveRDS(mc.mat, "output/00-1.mc.mat.rds")

# =================== 6准备pySCENIC的输入文件 =================== 

setwd(path2)
## (1) TF list文件(optional)，可以使用预定义的TF list，例如pySCENIC官方提供的，
##     或者animalTFDB提供的。
motif2tfs <- data.table::fread("../cisTarget_db/motifs-v10nr_clust-nr.hgnc-m0.001-o0.0.tbl")
TFs <- sort(unique(motif2tfs$gene_name))
writeLines(TFs, "../cisTarget_db/hsa_hgnc_tfs.motifs-v10.txt")

## (2) meta cell matrix (for step1): *.csv or *.loom
mc.mat <- readRDS("output/00-1.mc.mat.rds")
## (2.1) 过滤低表达基因
expr.in.cells <- rowSums(mc.mat > 0)
mc.mat <- mc.mat[expr.in.cells >= 5, ]
## (2.2) 过滤不在cisTargetDB中的基因
cisdb <- arrow::read_feather("../cisTarget_db/hg38_10kbp_up_10kbp_down_full_tx_v10_clust.genes_vs_motifs.rankings.feather")
genes.use <- intersect(colnames(cisdb), rownames(mc.mat))
length(genes.use)
dim(mc.mat)
mc.mat <- mc.mat[genes.use, ]
dim(mc.mat)
# =================== 7.保存为loom文件 =================== 
## 保存为loom文件
loom <- SCopeLoomR::build_loom(
  file.name         = "output/00-2.mc_mat_for_step1.loom",
  dgem              = mc.mat,
  default.embedding = NULL
)
loom$close()

## 释放loom对象，允许其它文件占用loom文件
rm(loom)
gc()

setwd(path1)
